SET ROLE {role};

-------------------------------------------------------------------------------------
-- IS TEXT AND VALUE
-------------------------------------------------------------------------------------
-- EXAMPLE
--'Neg(4)'
--'Neg(4.0)'
--'Neg(4:5)'
--'Neg(4-5)'
--'Neg(4..5)'
--'Neg(<4)'
--'Neg(<=4)'
--'Neg(4(4))'

drop function if exists {schema}.is_text_and_value(value_raw  varchar);
create or replace function {schema}.is_text_and_value(value_raw varchar)
    returns boolean
as
$body$
declare
    int_pattern varchar :=  '(0|[1-9][0-9]*)';
    time_int_pattern varchar :=  '(0|[0-9][0-9]*)';
    float_pattern varchar := '(([0-9]|[1-9][0-9]*)?[\.,][0-9]*)';
    number_pattern varchar := format('([+-]?(%s|%s))', float_pattern, int_pattern);

    ratio_pattern varchar := format('(%s\s*[\:/]\s*%s)', number_pattern, number_pattern); -- 3:4 vÃµi 3/4

    range_pattern1 varchar := concat('(', '\s*[>=<=><]{{1,2}}\s*', number_pattern, ')'); -- <3 <=3 >3 >=3
    range_pattern2 varchar := concat('(', number_pattern, '\s*\-\s*', number_pattern, ')'); -- 3-4 PROBLEEM 4..3 ka true
    range_pattern3 varchar := concat('(', number_pattern, '\s*\.\.\s*', number_pattern, ')'); -- 3..4
    range_pattern varchar := format('(%s|%s|%s)', range_pattern1, range_pattern2, range_pattern3);

    num_and_par_pattern varchar := format('(%s\s*\(%s\))', number_pattern, number_pattern); --3(3) PROBLEEM 5(3) ka TRUE, kuigi peaks olema FALSE
    -- num_and_par_pattern varchar := format('((%s)\(\1+\))', number_pattern);  -- does not work yet! matches same numbers e.g. 3(3)  but not different e.g. 5(3)

    time_series_pattern varchar := concat('^(',number_pattern, '\(', time_int_pattern, ':', time_int_pattern, '\),', ')*$');

    value_pattern varchar := concat('(\s*(', number_pattern, ')|(', ratio_pattern,')|(', range_pattern, ')|(', num_and_par_pattern, ')|(', time_series_pattern, '))');
    text_and_value_pattern varchar := concat('^\w+\(', value_pattern, '\)');
begin

    if value_raw ~ text_and_value_pattern then return True; end if;
    return False;
end
$body$
language plpgsql;

