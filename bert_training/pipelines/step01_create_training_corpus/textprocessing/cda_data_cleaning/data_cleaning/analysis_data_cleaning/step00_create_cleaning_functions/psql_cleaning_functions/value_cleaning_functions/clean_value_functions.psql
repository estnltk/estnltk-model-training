SET ROLE {role};

-------------------------------------------------------------------------------------
--CHECK TYPES
-------------------------------------------------------------------------------------
drop function if exists {schema}.check_types(text text);
create or replace function {schema}.check_types(text text)
    returns text
as
$body$
declare
begin

    if is_float(text) then return 'float'; end if;
    if is_integer(text) then return 'integer'; end if;
    if is_text(text) then return 'text'; end if;
    if is_num_and_par(text) then return 'num_and_par'; end if;
    if is_ratio(text) then return 'ratio'; end if;
    if is_time_series(text) then return 'time_series'; end if;
    if is_range(text) then return 'range'; end if;
    if is_text_and_value(text) then return 'text_and_value'; end if;
    return NULL;
end
$body$
language plpgsql;


-------------------------------------------------------------------------------------
-- SPLIT VALUE AND UNIT
-------------------------------------------------------------------------------------


-- Sometimes 'parameter_unit' is under 'value_raw' column and therefore 'parameter_unit_raw' is empty 
-- Function splits 'value_raw' into two:
	-- prefix is potentially a value
	-- suffix is potentially parameter_unit



drop function if exists {schema}.split_value_and_unit(value_raw text, OUT prefix varchar, OUT suffix varchar);
create or replace function {schema}.split_value_and_unit(value_raw text, OUT prefix varchar, OUT suffix varchar)
as
$body$
declare
    int_pattern varchar :=  '(0|[1-9][0-9]*)';
    float_pattern varchar := '(([0-9]|[1-9][0-9]*)?\s*[\.,][0-9]*)';
    number_pattern varchar := format('([+-]?(%s|%s))', float_pattern, int_pattern);

    ratio_pattern varchar := format('(%s\s*[\:/]\s*%s)', number_pattern, number_pattern); -- 3:4 vÃµi 3/4

    range_pattern1 varchar := format('(\s*[>=<=><]{{1,2}}\s*%s)', number_pattern); -- <3 <=3 >3 >=3
    range_pattern2 varchar := format('(%s\s*\-\s*%s)', number_pattern, number_pattern); -- 3-4 PROBLEEM 4..3 ka true
    range_pattern3 varchar := format('(%s\s*\.\.\s*%s)', number_pattern, number_pattern); -- 3..4
    range_pattern varchar := format('(%s|%s|%s)', range_pattern1, range_pattern2, range_pattern3);

    num_and_par_pattern varchar := format('(^%s\s*\(%s\))', number_pattern, number_pattern); --3(3) PROBLEEM 5(3) ka TRUE, kuigi peaks olema FALSE

    time_int_pattern varchar := '((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])';
    time_series_value_pattern varchar := format('(%s\s*|\s*%s\s*)', range_pattern, number_pattern);
    time_series_pattern varchar := format('^(%s\(%s\),)+$', time_series_value_pattern, time_int_pattern);

    value_pattern varchar := format('(^\s*(%s)|(%s)|(%s)|(%s)|(%s))', number_pattern, ratio_pattern, range_pattern, num_and_par_pattern, time_series_pattern);
    removal_pattern varchar := concat(value_pattern, '\s*');
begin
    value_raw := trim(value_raw);
    prefix := substring(value_raw, value_pattern);
    suffix := regexp_replace(value_raw, removal_pattern, '');
end
$body$
language plpgsql;

----------------------------------------------------------------------------------------------------------------
--CLEAN_VALUES
----------------------------------------------------------------------------------------------------------------
-- 1. Assigning value_type
	-- if suffix is actually a unit then value := prefix, parameter_unit := suffix
	-- if suffix is not a unit everything is left the same
-- 2. Placing units from 'value_raw' column to 'parameter_unit' column 
	-- if unit had accidentally been placed under 'value_raw' (and there is no unit under 'parameter_unit_raw') then move it under 'parameter_unit'
-- 3. Clean all the values based on their type


drop function if exists {schema}.clean_values(value_raw text, parameter_unit_raw varchar); --, OUT new_value varchar, OUT new_parameter_unit varchar);
create or replace function {schema}.clean_values(value_raw text, parameter_unit_raw varchar) --, new_value varchar, new_parameter_unit varchar)
    returns text[]
as
$body$
declare
    value_type varchar;
    new_value varchar;
    new_parameter_unit varchar;
    parameter_unit varchar;

    prefix varchar := trim((split_value_and_unit(value_raw)).prefix);
    suffix varchar := trim((split_value_and_unit(value_raw)).suffix);
begin
    if value_raw is null or value_raw ~ '^--+$'
        then return array[NULL, parameter_unit_raw]; end if;

    -- 0. PRE-CLEAN - ANONYM
    -- cleaning ANONYM values
    if value_raw ~ 'ANONYM' then
        select regexp_replace(value_raw,'<ANONYM.*>','ANONYM') into new_value;
        return  array[array[new_value]::varchar, parameter_unit_raw, NULL, NULL];
    end if;

    -- 1. PRE-CLEAN - HTML ESCAPES
    if value_raw ~ '(&lt;|&gt;)' then
        value_raw := replace(value_raw, '&lt;', '<');
        value_raw := replace(value_raw, '&gt;', '>');
    end if;

    -- 2. FINDING VALUE_TYPE
    -- suffix is actually a unit that has accidentally placed under 'value' column
    if suffix in (select unit from {schema}.{possible_units}) then
        value_type := check_types(prefix);
        new_parameter_unit := suffix;
        new_value := prefix;
    -- suffix is not a unit
    else value_type := check_types(value_raw);
         new_value := value_raw;
    end if;


    -- 3. CHECK IF UNIT HAS BEEN ACCIDENTALLY PLACED UNDER VALUE COLUMN
    if new_parameter_unit is not null and parameter_unit_raw is null THEN parameter_unit := new_parameter_unit;
    else parameter_unit := parameter_unit_raw;
    end if;


    -- 4. CLEANING VALUE
    --removes repeating white spaces
    new_value := trim(regexp_replace(new_value, '\s+', ' ', 'g'));

    -- postgres array can only have same datatypes stored in it
    -- as clean_time_series returns array (containig multiple rows), then all other values need to be converted to arrays as well
    if value_type = 'float'       then return array[array[clean_floats(new_value)]::varchar, parameter_unit, suffix, value_type]; end if;
    if value_type = 'integer'     then return array[array[clean_integer(new_value)]::varchar, parameter_unit, suffix, value_type]; end if;
    if value_type = 'text'        then return array[array[new_value]::varchar, parameter_unit, suffix, value_type]::varchar; end if; --don't know how to clean text
    if value_type = 'num_and_par' then return array[array[match_num_and_par(new_value)]::varchar, parameter_unit, suffix, value_type]; end if;
    if value_type = 'ratio'       then return array[array[match_ratio(new_value)]::varchar, parameter_unit, suffix, value_type]; end if;
    if value_type = 'range'       then return array[array[match_range(new_value)]::varchar, parameter_unit, suffix, value_type]; end if;
    if value_type = 'time_series' then return array[clean_time_series(new_value)::varchar, parameter_unit, suffix, value_type]; end if; 
    if value_type = 'text_and_value' then return array[array[new_value]::varchar, parameter_unit, suffix, value_type]; end if; --no cleaning yet!!!

    return array[array[new_value]::varchar, parameter_unit, suffix, value_type];

    end
$body$
language plpgsql;


